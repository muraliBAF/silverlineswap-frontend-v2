{"version":3,"sources":["utils/getTokenList.ts"],"names":["Ajv","allErrors","compile","schema","getTokenList","listUrl","resolveENSContentHash","a","parsedENS","parseENSAddress","ensName","contentHashUri","console","error","Error","translatedUri","contenthashToUri","urls","uriToHttp","ensPath","i","length","url","isLast","response","fetch","ok","json"],"mappings":"iQAS2B,IAAIA,IAAI,CAAEC,WAAW,IAAQC,QAAQC,GAOjD,SAAeC,EAA9B,oC,4CAAe,WACbC,EACAC,GAFa,iCAAAC,EAAA,2DAIPC,EAAYC,YAAgBJ,IAJrB,0CAScC,EAAsBE,EAAUE,SAT9C,OASTC,EATS,6DAWTC,QAAQC,MAAR,sCAA6CL,EAAUE,SAAvD,MACM,IAAII,MAAJ,sCAAyCN,EAAUE,UAZhD,kBAgBTK,EAAgBC,YAAiBL,GAhBxB,yDAkBTC,QAAQC,MAAM,yCAA0CF,GAClD,IAAIG,MAAJ,kDAAqDH,IAnBlD,QAqBXM,EAAOC,YAAU,GAAD,OAAIH,GAAJ,iBAAoBP,EAAUW,eAA9B,QAAyC,KArB9C,wBAuBXF,EAAOC,YAAUb,GAvBN,QAyBJe,EAAI,EAzBA,aAyBGA,EAAIH,EAAKI,QAzBZ,wBA0BLC,EAAML,EAAKG,GACXG,EAASH,IAAMH,EAAKI,OAAS,EAC/BG,OA5BO,sBA8BQC,MAAMH,GA9Bd,QA8BTE,EA9BS,6DAgCTZ,QAAQC,MAAM,uBAAwBR,EAAtC,OACIkB,EAjCK,uBAiCS,IAAIT,MAAJ,kCAAqCT,IAjC9C,kDAqCNmB,EAASE,GArCH,qBAsCLH,EAtCK,uBAsCS,IAAIT,MAAJ,kCAAqCT,IAtC9C,gEA0CQmB,EAASG,OA1CjB,eA0CLA,EA1CK,yBAmDJA,GAnDI,QAyBoBP,IAzBpB,8BAqDP,IAAIN,MAAM,mCArDH,0E","file":"static/js/43.d3cfd6a1.chunk.js","sourcesContent":["/* eslint-disable no-continue */\n/* eslint-disable no-await-in-loop */\nimport { TokenList } from '@uniswap/token-lists'\nimport schema from '@uniswap/token-lists/src/tokenlist.schema.json'\nimport Ajv from 'ajv'\nimport contenthashToUri from './contenthashToUri'\nimport { parseENSAddress } from './ENS/parseENSAddress'\nimport uriToHttp from './uriToHttp'\n\nconst tokenListValidator = new Ajv({ allErrors: true }).compile(schema)\n\n/**\n * Contains the logic for resolving a list URL to a validated token list\n * @param listUrl list url\n * @param resolveENSContentHash resolves an ens name to a contenthash\n */\nexport default async function getTokenList(\n  listUrl: string,\n  resolveENSContentHash: (ensName: string) => Promise<string>,\n): Promise<TokenList> {\n  const parsedENS = parseENSAddress(listUrl)\n  let urls: string[]\n  if (parsedENS) {\n    let contentHashUri\n    try {\n      contentHashUri = await resolveENSContentHash(parsedENS.ensName)\n    } catch (error) {\n      console.error(`Failed to resolve ENS name: ${parsedENS.ensName}`, error)\n      throw new Error(`Failed to resolve ENS name: ${parsedENS.ensName}`)\n    }\n    let translatedUri\n    try {\n      translatedUri = contenthashToUri(contentHashUri)\n    } catch (error) {\n      console.error('Failed to translate contenthash to URI', contentHashUri)\n      throw new Error(`Failed to translate contenthash to URI: ${contentHashUri}`)\n    }\n    urls = uriToHttp(`${translatedUri}${parsedENS.ensPath ?? ''}`)\n  } else {\n    urls = uriToHttp(listUrl)\n  }\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const isLast = i === urls.length - 1\n    let response\n    try {\n      response = await fetch(url)\n    } catch (error) {\n      console.error('Failed to fetch list', listUrl, error)\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\n      continue\n    }\n\n    if (!response.ok) {\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\n      continue\n    }\n\n    const json = await response.json()\n    // if (!tokenListValidator(json)) {\n    //   const validationErrors: string =\n    //     tokenListValidator.errors?.reduce<string>((memo, error) => {\n    //       const add = `${(error as any).dataPath} ${error.message ?? ''}`\n    //       return memo.length > 0 ? `${memo}; ${add}` : `${add}`\n    //     }, '') ?? 'unknown error'\n    //   throw new Error(`Token list failed validation: ${validationErrors}`)\n    // }\n    return json as TokenList\n  }\n  throw new Error('Unrecognized list URL protocol.')\n}\n"],"sourceRoot":""}